diff --git a/services/java/com/android/server/pm/PackageManagerService.java b/services/java/com/android/server/pm/PackageManagerService.java
index 220bec0..6dd2df9 100644
--- a/services/java/com/android/server/pm/PackageManagerService.java
+++ b/services/java/com/android/server/pm/PackageManagerService.java
@@ -510,6 +510,96 @@ public class PackageManagerService extends IPackageManager.Stub {
 
     private Map<String, Long> mAvailableCommonResources = new HashMap<String, Long>();
 
+    private static boolean[] cpu_prev_state = new boolean[3];
+
+    private static void recordCPUStates() {
+
+    	String path_start = "/sys/devices/system/cpu/cpu";
+        String path_tail = "/online";
+
+        try{
+
+		for(int i = 1; i < 4; i ++) {
+			File cpu_online = new File(path_start + String.valueOf(i) + path_tail);
+			if(cpu_online.exists() && cpu_online.canRead()){
+				FileInputStream fis = new FileInputStream(cpu_online);
+				int state = fis.read();
+				Log.i("MultiThreaded-MultiCore dexopt:", "CPU "+ String.valueOf(i) +" record state=" + 
+					String.valueOf(state));
+				fis.close();
+				cpu_prev_state[i -1] = (state == 49);
+			}
+		}
+
+       }catch (Exception ex){ex.printStackTrace();}
+
+    }
+
+    private static void restoreCPUStates() {
+
+    	String path_start = "/sys/devices/system/cpu/cpu";
+        String path_tail = "/online";
+
+        try{
+
+		for(int i = 1; i < 4; i ++) {
+			File cpu_online = new File(path_start + String.valueOf(i) + path_tail);
+			if(cpu_online.exists() && cpu_online.canWrite()){
+				FileOutputStream fos = new FileOutputStream(cpu_online);
+				if(cpu_prev_state[i -1]){
+					Log.i("MultiThreaded-MultiCore dexopt:", "Bringing " + 
+						"up" +" CPU " + String.valueOf(i));
+					fos.write((byte)49);
+				} else {
+					Log.i("MultiThreaded-MultiCore dexopt:", "Bringing " + 
+						"down" +" CPU " + String.valueOf(i));
+					fos.write((byte)48);
+				}
+
+				Log.i("MultiThreaded-MultiCore dexopt:", " restore state=" + 
+					String.valueOf(cpu_prev_state[i -1]));
+				fos.close();
+			}
+		}
+
+       }catch (Exception ex){ex.printStackTrace();}
+
+    }
+
+    private static void enableAllCores() {
+
+	String path_start = "/sys/devices/system/cpu/cpu";
+        String path_tail = "/online";
+
+        try{
+
+		for(int i = 1; i < 4; i ++) {
+			File cpu_online = new File(path_start + String.valueOf(i) + path_tail);
+			if(cpu_online.exists() && cpu_online.canWrite()){
+				FileOutputStream fos = new FileOutputStream(cpu_online);
+				Log.i("MultiThreaded-MultiCore dexopt:", "Bringing " + 
+					"up" +" CPU " + String.valueOf(i));
+				fos.write((byte)49);
+				fos.close();
+			}
+		}
+
+       }catch (Exception ex){ex.printStackTrace();}
+
+    }
+
+    private static void extraCPUCores(boolean enable) {
+
+	if(enable) {
+		recordCPUStates();
+		enableAllCores();
+	} else {
+		restoreCPUStates();
+	}
+
+    }
+
+
     // Set of pending broadcasts for aggregating enable/disable of components.
     static class PendingPackageBroadcasts {
         // for each user id, a map of <package name -> components within that package>
@@ -1166,7 +1256,8 @@ public class PackageManagerService extends IPackageManager.Stub {
             Slog.w(TAG, "**** ro.build.version.sdk not set!");
         }
 
-        mIsMultiThreaded = !"false".equals(SystemProperties.get("persist.sys.dalvik.multithread"));
+        /* Overide! Let's always use this! */
+        mIsMultiThreaded = (Runtime.getRuntime().availableProcessors() > 1);
 
         mContext = context;
         mFactoryTest = factoryTest;
@@ -1287,7 +1378,10 @@ public class PackageManagerService extends IPackageManager.Stub {
                  */
                 if (mSharedLibraries.size() > 0) {
                     Iterator<SharedLibraryEntry> libs = mSharedLibraries.values().iterator();
-                    ExecutorService executorService = Executors.newFixedThreadPool(sNThreads);
+		    if(mIsMultiThreaded)
+		    	extraCPUCores(true);
+
+                    ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
                     while (libs.hasNext()) {
                         final String lib = libs.next().path;
                         if (lib == null) {
@@ -1319,6 +1413,9 @@ public class PackageManagerService extends IPackageManager.Stub {
                     executorService.shutdown();
                     try {
                         executorService.awaitTermination(1, TimeUnit.DAYS);
+        		if(mIsMultiThreaded)
+		        	extraCPUCores(false);
+
                     } catch (InterruptedException e) {
                         e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
                     }
@@ -1342,7 +1439,10 @@ public class PackageManagerService extends IPackageManager.Stub {
                  */
                 String[] frameworkFiles = frameworkDir.list();
                 if (frameworkFiles != null) {
-                    ExecutorService executorService = Executors.newFixedThreadPool(sNThreads);
+		    if(mIsMultiThreaded)
+		    	extraCPUCores(true);
+
+                    ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
                     for (int i = 0; i < frameworkFiles.length; i++) {
                         File libPath = new File(frameworkDir, frameworkFiles[i]);
                         final String path = libPath.getPath();
@@ -1378,6 +1478,9 @@ public class PackageManagerService extends IPackageManager.Stub {
                     executorService.shutdown();
                     try {
                         executorService.awaitTermination(1, TimeUnit.DAYS);
+        		if(mIsMultiThreaded)
+				extraCPUCores(false);
+
                     } catch (InterruptedException e) {
                         e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
                     }
@@ -3720,8 +3823,10 @@ public class PackageManagerService extends IPackageManager.Stub {
             return;
         }
 
-        ExecutorService executorService = Executors.newFixedThreadPool(sNThreads);
+	if(mIsMultiThreaded)
+		extraCPUCores(true);
 
+        ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
         if (DEBUG_PACKAGE_SCANNING) {
             Log.d(TAG, "Scanning app dir " + dir + " scanMode=" + scanMode
                     + " flags=0x" + Integer.toHexString(flags));
@@ -3757,6 +3862,9 @@ public class PackageManagerService extends IPackageManager.Stub {
         executorService.shutdown();
         try {
             executorService.awaitTermination(1, TimeUnit.DAYS);
+	        if(mIsMultiThreaded)
+		    extraCPUCores(false);
+
         } catch (InterruptedException e) {
             e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
         }
@@ -4090,7 +4198,10 @@ public class PackageManagerService extends IPackageManager.Stub {
         if (pkgs != null) {
             final AtomicInteger i = new AtomicInteger(0);
             final int pkgsSize = pkgs.size();
-            ExecutorService executorService = Executors.newFixedThreadPool(sNThreads);
+	    if(mIsMultiThreaded)
+		extraCPUCores(true);
+
+            ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
             for (PackageParser.Package pkg : pkgs) {
                 final PackageParser.Package p = pkg;
                 synchronized (mInstallLock) {
@@ -4122,6 +4233,9 @@ public class PackageManagerService extends IPackageManager.Stub {
             executorService.shutdown();
             try {
                 executorService.awaitTermination(1, TimeUnit.DAYS);
+        	if(mIsMultiThreaded)
+	        	extraCPUCores(false);
+
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
